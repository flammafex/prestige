/**
 * Witness Adapter
 * Handles BFT timestamping for ballot creation, votes, and results
 *
 * Witness provides cryptographic proof that something existed at a specific time.
 * Multiple witnesses sign the timestamp, requiring a threshold for validity.
 *
 * API v1:
 * - POST /v1/timestamp { hash: "hex" } -> { attestation: SignedAttestation }
 * - POST /v1/verify { attestation: SignedAttestation } -> { valid, verified_signatures, required_signatures }
 * - GET /v1/config -> NetworkConfig with witness info and threshold
 */

import type { WitnessAttestation, Hash } from '../types.js';

export interface WitnessConfig {
  gatewayUrl: string;
  timeout?: number;
  /** Minimum signatures required (fetched from server if not set) */
  threshold?: number;
}

/**
 * Witness API response types
 */
interface TimestampResponse {
  attestation: SignedAttestationResponse;
}

interface SignedAttestationResponse {
  attestation: {
    hash: number[];  // byte array
    timestamp: number;
    network_id: string;
    sequence: number;
  };
  signatures: MultiSigSignatures | AggregatedSignatures;
}

interface MultiSigSignatures {
  signatures: Array<{
    witness_id: string;
    signature: number[];  // byte array
  }>;
}

interface AggregatedSignatures {
  signature: number[];  // aggregated BLS signature
  signers: string[];    // list of witness IDs
}

interface VerifyResponse {
  valid: boolean;
  verified_signatures: number;
  required_signatures: number;
  message: string;
}

interface NetworkConfigResponse {
  id: string;
  witnesses: Array<{
    id: string;
    pubkey: string;
    endpoint: string;
  }>;
  threshold: number;
  signature_scheme: 'Ed25519' | 'BLS';
}

export interface WitnessAdapter {
  /**
   * Get an attestation for a hash
   * Note: timestamp is generated by the witness service
   */
  attest(hash: Hash): Promise<WitnessAttestation>;

  /**
   * Verify an attestation is valid
   */
  verify(attestation: WitnessAttestation): Promise<boolean>;

  /**
   * Check if the Witness service is available
   */
  healthCheck(): Promise<boolean>;
}

/**
 * HTTP-based Witness adapter for production use
 */
export class HttpWitnessAdapter implements WitnessAdapter {
  private timeout: number;
  private threshold: number | null;
  private networkConfig: NetworkConfigResponse | null = null;

  constructor(private config: WitnessConfig) {
    this.timeout = config.timeout ?? 10000;
    this.threshold = config.threshold ?? null;
  }

  /**
   * Fetch network configuration (including threshold)
   */
  private async fetchConfig(): Promise<void> {
    if (this.networkConfig) return;

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      const response = await fetch(`${this.config.gatewayUrl}/v1/config`, {
        signal: controller.signal,
      });

      if (response.ok) {
        this.networkConfig = await response.json() as NetworkConfigResponse;
        if (this.threshold === null) {
          this.threshold = this.networkConfig.threshold;
        }
        console.log(`[Witness] Connected to network: ${this.networkConfig.id} (threshold: ${this.networkConfig.threshold})`);
      }
    } catch {
      // Config fetch is optional, use defaults
    } finally {
      clearTimeout(timeoutId);
    }
  }

  async attest(hash: Hash): Promise<WitnessAttestation> {
    await this.fetchConfig();

    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);
    const url = `${this.config.gatewayUrl}/v1/timestamp`;

    try {
      console.log(`[Witness] POST ${url}`);
      const response = await fetch(url, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ hash }),  // Just hash, server generates timestamp
        signal: controller.signal,
      });

      if (!response.ok) {
        const body = await response.text().catch(() => '');
        throw new WitnessError(
          `Failed to get attestation: ${response.status} ${response.statusText} - ${url}${body ? ` - ${body}` : ''}`,
          'ATTEST_FAILED'
        );
      }

      const data = await response.json() as TimestampResponse;
      return this.parseAttestation(data);
    } finally {
      clearTimeout(timeoutId);
    }
  }

  /**
   * Parse the nested attestation response into WitnessAttestation
   */
  private parseAttestation(data: TimestampResponse): WitnessAttestation {
    const { attestation: signed } = data;
    const { attestation, signatures } = signed;

    // Convert byte array hash to hex string
    const hashHex = bytesToHex(attestation.hash);

    // Handle both MultiSig and Aggregated signature formats
    let witnessSignatures: Array<{ witnessId: string; signature: string }>;
    let witnessIds: string[];

    if ('signatures' in signatures) {
      // MultiSig format
      witnessSignatures = signatures.signatures.map(s => ({
        witnessId: s.witness_id,
        signature: bytesToHex(s.signature),
      }));
      witnessIds = witnessSignatures.map(s => s.witnessId);
    } else {
      // Aggregated (BLS) format
      witnessSignatures = [{
        witnessId: 'aggregated',
        signature: bytesToHex(signatures.signature),
      }];
      witnessIds = signatures.signers;
    }

    return {
      hash: hashHex,
      timestamp: attestation.timestamp,
      signatures: witnessSignatures,
      witnessIds,
      networkId: attestation.network_id,
      sequence: attestation.sequence,
    };
  }

  async verify(attestation: WitnessAttestation): Promise<boolean> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), this.timeout);

    try {
      // Convert back to API format for verification
      const apiAttestation = this.toApiFormat(attestation);

      const response = await fetch(`${this.config.gatewayUrl}/v1/verify`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ attestation: apiAttestation }),
        signal: controller.signal,
      });

      if (!response.ok) {
        return false;
      }

      const data = await response.json() as VerifyResponse;
      return data.valid === true;
    } catch {
      console.warn('[Witness] Verification failed');
      return false;
    } finally {
      clearTimeout(timeoutId);
    }
  }

  /**
   * Convert WitnessAttestation back to API format for verification
   */
  private toApiFormat(attestation: WitnessAttestation): SignedAttestationResponse {
    return {
      attestation: {
        hash: hexToBytes(attestation.hash),
        timestamp: attestation.timestamp,
        network_id: attestation.networkId ?? 'prestige',
        sequence: attestation.sequence ?? 0,
      },
      signatures: {
        signatures: attestation.signatures.map(s => ({
          witness_id: s.witnessId,
          signature: hexToBytes(s.signature),
        })),
      },
    };
  }

  async healthCheck(): Promise<boolean> {
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), 5000);

    try {
      const response = await fetch(`${this.config.gatewayUrl}/health`, {
        signal: controller.signal,
      });
      return response.ok;
    } catch {
      return false;
    } finally {
      clearTimeout(timeoutId);
    }
  }
}

// Helper functions
function bytesToHex(bytes: number[]): string {
  return bytes.map(b => b.toString(16).padStart(2, '0')).join('');
}

function hexToBytes(hex: string): number[] {
  const bytes: number[] = [];
  for (let i = 0; i < hex.length; i += 2) {
    bytes.push(parseInt(hex.substr(i, 2), 16));
  }
  return bytes;
}

/**
 * Mock Witness adapter for testing and development
 */
export class MockWitnessAdapter implements WitnessAdapter {
  private attestations = new Map<string, WitnessAttestation>();
  private witnessIds = ['witness-1', 'witness-2', 'witness-3'];
  private threshold: number;
  private networkId = 'mock-network';
  private sequence = 0;

  constructor(options?: { threshold?: number; networkId?: string }) {
    this.threshold = options?.threshold ?? 2;
    if (options?.networkId) {
      this.networkId = options.networkId;
    }
  }

  async attest(hash: Hash): Promise<WitnessAttestation> {
    // Server generates timestamp
    const timestamp = Math.floor(Date.now() / 1000);
    this.sequence++;

    const attestation: WitnessAttestation = {
      hash,
      timestamp,
      signatures: this.witnessIds.slice(0, this.threshold).map(id => ({
        witnessId: id,
        signature: `mock-sig-${id}-${hash.slice(0, 8)}-${timestamp}`,
      })),
      witnessIds: this.witnessIds.slice(0, this.threshold),
      networkId: this.networkId,
      sequence: this.sequence,
    };

    this.attestations.set(hash, attestation);
    return attestation;
  }

  async verify(attestation: WitnessAttestation): Promise<boolean> {
    // Check threshold
    if (attestation.signatures.length < this.threshold) {
      return false;
    }

    // Check all witness IDs are valid
    const validWitnesses = attestation.witnessIds.every(id =>
      this.witnessIds.includes(id)
    );
    if (!validWitnesses) {
      return false;
    }

    // Check signatures match witness IDs
    const signatureWitnessIds = attestation.signatures.map(s => s.witnessId);
    const signaturesValid = attestation.witnessIds.every(id =>
      signatureWitnessIds.includes(id)
    );

    return signaturesValid;
  }

  async healthCheck(): Promise<boolean> {
    return true;
  }

  // Test helpers
  setWitnessIds(ids: string[]): void {
    this.witnessIds = ids;
  }

  setThreshold(threshold: number): void {
    this.threshold = threshold;
  }

  clearAttestations(): void {
    this.attestations.clear();
  }
}

/**
 * Witness-specific error
 */
class WitnessError extends Error {
  constructor(message: string, public code: string) {
    super(message);
    this.name = 'WitnessError';
  }
}
